// Main Code

#include "simpletools.h"                      // Include simple tools
#include "servo.h"                            // Include servo library
#include "ping.h"  
#include "stdbool.h"                           // Include ping sensor library

int white = 0;
int black = 1;
const int ON  = 22;
const int CLR = 12;
int c_intersection=0;
static volatile int distance;
bool slowdownflag = false;

// Global vars for cogs to share
unsigned int stack[40 + 25]; // Stack vars for cog1
int ob_distance=20;

//serial *lcd;

bool finish = false;
bool localfinish = false;
const int leftWheel=16;
const int rightWheel=17;
const int ultrasonic=11;
const int TxPin = 12;
const int IR_ML=4;
const int IR_MR=8;
const int led=7;

void avoid_obstacle();
void obstacle(void *dist);
void drive(char i);
void lcd_display(char disp);
bool linefollowing();
void test();

//Defining getDistance function


//Defining drive function
void drive(char i) {
  int speed;
  if(slowdownflag==true)
    speed=30;
  else
    speed=50;
  switch(i){
  // f, b, l, r, s means forward, backward, left, right, and stop
    case 'f':servo_speed(leftWheel, speed);servo_speed(rightWheel, -speed);pause(20);break;
    case 'b':servo_speed(leftWheel, -speed);servo_speed(rightWheel, speed);pause(20);break;
    case 'l':servo_speed(leftWheel, -speed);servo_speed(rightWheel, -speed);pause(20);break;
    case 'r':servo_speed(leftWheel, speed);servo_speed(rightWheel, speed);pause(20);break;
    case 's':servo_speed(leftWheel, 0);servo_speed(rightWheel, 0);pause(20);break;
    default:print("Unclear command for motors");break;
  }
}

//run this method continuesly to follow the line until the robot meets an intersection
bool linefollowing(){
  int SL = input(IR_ML);
  int SR = input(IR_MR);
  if (SL == white && SR == white) {
    //forward
    drive('f');return true;
  }
  else if (SL == black && SR== white) {
    //turn left
    drive('l');return true;
  }
  else if (SL == white &&  SR == black) {
    // Turn right
    drive('r');return true;
  }
  else {
    // Stop
    drive('s');return false;
  }
}

// Cog2 function for blinking led
void led_blink(void *ledPin) {
  while(1) {
    if(ledflag==true) {
      high(led);
      pause(500);
      low(led);
      pause(500);
      ledflag=false;
    } 
  }
}

// Function for getting distance from object to be picked up
void ultrasonic2() {
  low(trigPin);
  pasue(2);
  high(trigPin);
  pause(10);
  low(trigPin);
  duration = pulse_in(echoPin, 1);
  distance2 = duration * 0.034/2;
}

// Function for checking for object to be picked up
bool isobject() {
  if(distance2<20)
    return true;
  else
    return false;
}

bool isobstacle() {
  if (distance<ob_distance){
    return true;}
  else{
    return false;}
}


//Defining lcd display function
/*void lcd_display(char disp) {
  writeChar(lcd, CLR);
  pause(5);
  
  switch(disp) {
    case 'i':dprint(lcd, "Intersection");  // i - Intersection detected
             writeChar(lcd, LINE2);
             dprint(lcd, "Detected");
             pause(1000);
             break; 
    default:print("Unclear command for display");break;
  }
}*/

//for test purpose
void test(){
}

void obstacle(void *dist) {
  while(1) {
    distance = ping_cm(ultrasonic); // Get cm distance from Ping)))
    pause(200); // Wait 1/5 second
   }
}

void avoid_obstacle(){
  int c_itsc=0;
  bool isintersection;
  while(true){
    isintersection=!linefollowing()
    while(isobstacle() == true)
      drive('s');          
    if(isintersection && c_itsc==0) { //if meet intersection
      drive('f');pause(500); 
      drive('r');pause(1000); //turn 90
      slowdownflag=true;
      c_itsc++;
    }
    else if(isintersection && c_itsc==1){
      slowdownflag=false;
      drive('f');pause(500);
      drive('r');pause(1000); // Turn right
      c_itsc++;
    }
    else if(isintersection && c_itsc==2){
      c_intersection++;
      drive('f');pause(500);
      drive('l');pause(1000); // Turn left
      if(isobstacle()==true) {
        drive('l');pause(500);
        c_itsc=0;
      }        
    }
  }
}


int main()
{
  cogstart(&obstacle, NULL, stack, sizeof(stack));      // Starting cog for detecting obstacles
  cogstart(&led_blink, NULL, stack1, sizeof(stack1));

  // 1 go through the center course
  localfinish=false;
  while(!localfinish){
    if(!linefollowing()){     //if meet intersection
      c_intersection++;
      //lcd_display('i');
      if(isobstacle()==true) {
        drive('f');pause(500);
        drive('l');pause(1000);
        avoid_obstacle();
      }
      else 
        drive('f');pause(1000); // Move straight
      if(c_intersection==5) 
        localfinish=true;
    }
  }

  // 2 go through pick up course
  localfinish=false;
  int c_p=0;
  bool isintersection=false;
  while(!localfinish) {
    isintersection=!linefollowing();
    while(isobstacle() == true) 
      drive('s');
    if(isintersection && c_p==0) {
      drive('f');pause(500);
      drive('r');pause(1000);
      c_p++;
    }
    else if(isintersection && c_p==1) {
      if(isobstacle())
        pickup=5;
      drive('f');pause(500);
      drive('r');pause(1000);
      c_p++;
      slowdownflag=true;
    }
    else if(isintersection && c_p>1 && c_p<5) {
      if(isobject())
        pickup=6-c_p;
      drive('f');pause(1000);
      c_p++;        
    }
    else if(isintersection && c_p==5) {
      if(isobject())
        pickup=1;
      slowdownflag=false;
      drive('f');pause(500);
      drive('r');pause(1000);
    }
    else if(isintersection && c_p==6){   //cross the center course
      drive('f');puse(1000);
      localfinish=true;
    }
  }

  // 3 go through and stop at drop point
  int c_d=1;
  localfinish=false;
  while(localfinish){
    isintersection=linefollowing();
    while(isobstacle() == true)
      drive('s');
    if(isintersection && c_d==1){
      if(isobstacle()){
        drive('s');break;
        dropoff=c_d;
      }
      drive('f');pause(500);
      drive('r');pause(1000);
      slowdownflag=true;
    }
    else if(isintersection && isobject()){
      // arrived drop point
      if(isobject()){
        drive('s');break;
        dropoff=c_d;
      }
    }
    else if(isintersection)
      drive('f');pause(1000);
  }

  int pd_distance=40*(pickup+dropoff);
  // lcd display
}             
